#pragma kernel WaterIncrement
#pragma kernel OutflowFluxComputation
#pragma kernel VectorFieldAndWaterComputation
#pragma kernel ErosionComputation
#pragma kernel SedimentTransportationAndEvaporation

struct CellData
{
    float TerrainHeight;
    float WaterHeight;
    float Sediment;
    float Hardness;
    float4 WaterOutflowFlux;
    float2 Velocity;
};

RWStructuredBuffer<CellData> Data;

// some general constants
float MapSize;
float DeltaTime;
float HeightScale;
float Gravity;

// some erosion rates
float RainRate;
float EvaporationRate;
float SoilSuspensionRate;
float SedimentDepositionRate;
float SedimentSofteningRate;

// virtual pipe model constants
float PipeLength;
float PipeCrossArea;
float2 CellSize;

// other simulation constants
float SedimentCapacity;
float MaxErosionDepth;
float MinHardness;

// some useful defines
#define GET_TERRAIN_HEIGHT(id2d) Data[(int)id2d.y * MapSize + id2d.x].TerrainHeight * HeightScale
#define GET_WATER_HEIGHT(id2d) Data[(int)id2d.y * MapSize + id2d.x].WaterHeight
#define GET_FULL_HEIGHT(id2d) GET_TERRAIN_HEIGHT(id2d) + GET_WATER_HEIGHT(id2d)
#define NUMTHREADS numthreads(16, 16, 1)

[NUMTHREADS]
void WaterIncrement(uint3 id : SV_DispatchThreadID)
{
    int index = id.y * MapSize + id.x;
    CellData currentCell = Data[index];
    
    currentCell.WaterHeight += RainRate * DeltaTime;
    
    Data[index] = currentCell;
}

[NUMTHREADS]
void OutflowFluxComputation(uint3 id : SV_DispatchThreadID)
{
    int index = id.y * MapSize + id.x;
    CellData currentCell = Data[index];
    
    // left right top bottom
    float4 outFlux = currentCell.WaterOutflowFlux;
    float4 neighbourFullHeights = float4(
        GET_FULL_HEIGHT((id.xy - uint2(1, 0))),
        GET_FULL_HEIGHT((id.xy + uint2(1, 0))),
        GET_FULL_HEIGHT((id.xy - uint2(0, 1))),
        GET_FULL_HEIGHT((id.xy + uint2(0, 1)))
    );
    
    float4 deltaHeight = GET_FULL_HEIGHT(id.xy) - neighbourFullHeights;
    
    // calculate outFlux
    outFlux = max(0.0f, outFlux + DeltaTime * PipeCrossArea * Gravity * deltaHeight / PipeLength);
    
    float totalFlux = outFlux.x + outFlux.y + outFlux.z + outFlux.w;
    float k = min(1.0f, currentCell.WaterHeight * CellSize.x * CellSize.y /
        (totalFlux * DeltaTime));

    outFlux *= k;
    
    if (id.x == 0) 
        outFlux.x = 0.f;
    if (id.x == (uint)MapSize - 1) 
        outFlux.y = 0.f;
    if (id.y == 0) 
        outFlux.z = 0.f;
    if (id.y == (uint)MapSize - 1)
        outFlux.w = 0.f;
    
    currentCell.WaterOutflowFlux = outFlux;
    Data[index] = currentCell;
}

// doing this in another kernel to sinc all the outputfluxes
[NUMTHREADS]
void VectorFieldAndWaterComputation(uint3 id : SV_DispatchThreadID)
{
    int index = id.y * MapSize + id.x;
    CellData currentCell = Data[index];
    
    // left right top bottom
    float4 outFlux = currentCell.WaterOutflowFlux;
    float4 inFlux = 0.0f;
    
    inFlux.x = id.x < (uint)MapSize - 1 ? Data[index + 1].WaterOutflowFlux.x : 0.0f;
    inFlux.y = id.x > 0 ? Data[index - 1].WaterOutflowFlux.y : 0.0f;
    inFlux.z = id.y < (uint)MapSize - 1 ? Data[index + MapSize].WaterOutflowFlux.z : 0.0f;
    inFlux.w = id.y > 0 ? Data[index - MapSize].WaterOutflowFlux.w : 0.0f;
    
    float totalOutFlux = outFlux.x + outFlux.y + outFlux.z + outFlux.w;
    float totalInFlux = inFlux.x + inFlux.y + inFlux.z + inFlux.w;
    
    currentCell.WaterHeight += DeltaTime * (totalInFlux - totalOutFlux) / (CellSize.x * CellSize.y);
    
    currentCell.Velocity = float2(
        (inFlux.y - outFlux.x + outFlux.y - inFlux.x) * 0.5f,
        (inFlux.w - outFlux.z + outFlux.w - inFlux.z) * 0.5f
    );
    
    Data[index] = currentCell;
}

// Erosion + deposition + sediment transportation
[NUMTHREADS]
void ErosionComputation(uint3 id : SV_DispatchThreadID)
{
    int index = id.y * MapSize + id.x;
    CellData currentCell = Data[index];
    
    float tHeight = GET_TERRAIN_HEIGHT(id);
    
    // left right top bottom
    float4 tHeightNeighbours = 0.0f;
    tHeightNeighbours.x = id.x > 0 ? GET_TERRAIN_HEIGHT((id.xy - int2(1, 0))) : tHeight;
    tHeightNeighbours.y = id.x < (uint)MapSize - 1 ? GET_TERRAIN_HEIGHT((id.xy + int2(1, 0))) : tHeight;
    tHeightNeighbours.z = id.y > 0 ? GET_TERRAIN_HEIGHT((id.xy - int2(0, 1))) : tHeight;
    tHeightNeighbours.w = id.y < (uint)MapSize - 1 ? GET_TERRAIN_HEIGHT((id.xy + int2(0, 1))) : tHeight;
    
    float dhdx = (tHeightNeighbours.y - tHeightNeighbours.x) / (2 * CellSize.x);
    float dhdz = (tHeightNeighbours.w - tHeightNeighbours.z) / (2 * CellSize.x);
    
    // generate normal
    float3 dhdxVect = normalize(float3(1.0f, dhdx, 0.0f));
    float3 dhdzVect = normalize(float3(0.0f, dhdz, 1.0f));
    float3 n = normalize(cross(dhdxVect, dhdzVect));
    
    // compute tilt angle
    float dotProd = dot(n, float3(0.0f, 1.0f, 0.0f));
    float alpha = acos(dotProd);
    float tiltAngle = sin(alpha);
    
    // compute limiting function
    float limit = clamp(1 - (MaxErosionDepth - currentCell.WaterHeight) / MaxErosionDepth, 0.0f, 1.0f);
    
    // compute water sediment transport capacity
    float sedimentTransportCapacity = SedimentCapacity * tiltAngle * length(currentCell.Velocity) * limit;
    float tempSediment = currentCell.Sediment;
    if (sedimentTransportCapacity > currentCell.Sediment)
    {
        // soil eroded and added to suspended sediment
        float soilRemoved = DeltaTime * currentCell.Hardness * SoilSuspensionRate * (sedimentTransportCapacity - currentCell.Sediment);
        currentCell.TerrainHeight = (tHeight - soilRemoved) / HeightScale;
        tempSediment += soilRemoved;
        currentCell.WaterHeight += soilRemoved;
    }
    else
    {
        // soil deposited
        float soilDeposited = DeltaTime * SedimentDepositionRate * (currentCell.Sediment - sedimentTransportCapacity);
        currentCell.TerrainHeight = (tHeight + soilDeposited) / HeightScale;
        tempSediment -= soilDeposited;
        currentCell.WaterHeight -= soilDeposited;
    }
    
    float updatedHardness = currentCell.Hardness - DeltaTime * SedimentSofteningRate * SoilSuspensionRate * (currentCell.Sediment - sedimentTransportCapacity);
    
    currentCell.Hardness = max(updatedHardness, MinHardness);
    
    currentCell.Sediment = tempSediment;
    
    Data[index] = currentCell;
}

[NUMTHREADS]
void SedimentTransportationAndEvaporation(uint3 id : SV_DispatchThreadID)
{
    int index = id.y * MapSize + id.x;
    CellData currentCell = Data[index];
    
    // transport suspended sediment //
    
    // calculate indices for bilinear interpolation + 
    // no need for bounds check since velocities can't point outside the map
    float2 pos = float2(id.x, id.y) - float2(currentCell.Velocity.x, currentCell.Velocity.y) * DeltaTime;
    
    float2 ceilPos = ceil(pos);
    float2 floorPos = floor(pos);
    
    float topLeftIndex = ceilPos.y * MapSize + floorPos.x;
    float topRightIndex = ceilPos.y * MapSize + ceilPos.x;
    float bottomLeftIndex = floorPos.y * MapSize + floorPos.x;
    float bottomRightIndex = floorPos.y * MapSize + ceilPos.x;
    
    float dx = pos.x - floorPos.x;
    float dy = pos.y - floorPos.y;
    
    float interpolateXBottom = Data[bottomLeftIndex].Sediment * (1 - dx) + Data[bottomRightIndex].Sediment * dx;
    float interpolateXTop = Data[topLeftIndex].Sediment * (1 - dx) + Data[topRightIndex].Sediment * dx;
    
    // calculate interpolated sediment
    float interpolatedSediment = interpolateXBottom * (1 - dy) + interpolateXTop * dy;
    
    currentCell.Sediment = interpolatedSediment;
    
    // evaporate water //
    currentCell.WaterHeight *= 1 - EvaporationRate * DeltaTime;
    
    GroupMemoryBarrierWithGroupSync();
    Data[index] = currentCell;
}
